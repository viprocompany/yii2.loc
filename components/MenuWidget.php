<?php


namespace app\components;


use app\models\Category;
use yii\base\Widget;

class MenuWidget extends Widget
{
//свойство темплэйта для меню в зависимости от шаблона, куда оно подключено
  public $tpl;
  //css class for menu
  public $ul_class;
//array categories
  public $data;
//дерево категорий
  public $tree;
//готовая верстка ,котрую вернет метод run()
  public $menuHtml;
  // проверять активность категории, в $model будет находится текущая категория. Если в адресной сторке айдишник   категории равен айдишнику категории в выпадающем списке , то она становится неактивной/ также будет   сравниваться значение parent_id текущей категории и тем, которое есть в $model и к\если они будут совпадать, то  есть она будет выбранной , селект будет подсвечиваться
  public $model;
  //время кеширования для админки
public $cache_time = 60;

  public function init()
  {
    parent::init();

  if ($this->tpl === null){
    $this->tpl = 'menu';
  }
  //так как мы можем получать название шаблона из настроек как именованный вид без расширения , то после прохождения проверки к нему будет добавляться расширение php . первоначально тоже будет создаваться название темплейта прибавлением php к menu : menu.php
$this->tpl .= '.php';

    if ($this->ul_class === null){
      $this->ul_class = 'menu';
    }
  }

public function run()
{
  //get cache получаем данные из кеша если они есть, при условии, что задано значение свойства  о времени кеширования $cache_time, если значение 0, то значит кеш не будет использован меню оттуда не берем, все значения будут взяты из БД
  if ($this->cache_time){
    $menu = \Yii::$app->cache->get('menu');
    if ($menu){
      return $menu;
    }
  }

  $this->data = Category::find()->select('id,parent_id,title')->indexBy('id')->asArray()->all();
  //ПОЛУЧАЕМ ДАННЫЕ. ИЗ БАЗЫ вывод всех подряд категорий как массива из таблицы Category
//  debug($this->data);
  //СТРОИМ ДЕРЕВО. исскуственно созданый массив с иерархией из метода getTree, перестроенному по типу битриксового резалт.модифайра
  $this->tree =  $this->getTree();
//  debug($this->tree);
  //ИЗ ДЕРЕВА СТРОИМ ВЕРСТКУ МЕНЮ С ДИНАМИКОЙ
  //начинаем собирать разметку с ула, в который предаем класс в файле сайдбара , при подключении виджета меню в массиве его параметров
  $this->menuHtml = '<ul class="' . $this->ul_class . '">';
  //возвращаем  темплэйт с параметром из массива со вложенными массивами дочерних категорий в родительские
  //код нашего виджета , заполняемый разделами и подразделами
  $this->menuHtml .= $this->getMenuHtml($this->tree);
  //закрываем ул
  $this->menuHtml .= '</ul>';

  //если  для cache_time установлено значение по времени кеширования
  if($this->cache_time){
    //set cache установим кэш. он будет в папке runtime/cache/me/menu
    \Yii::$app->cache->set('menu',$this->menuHtml, $this->cache_time);
  }

  //возвращаем собранный шаблон
return $this->menuHtml;
}


  public function getTree()
  {
    //Tommy Lacroit
    //строим дерево категорий
    $tree = [];
    //проходим циклом по категориям, полученным в методе run и задаем ключ и значение $id=>%$node
    foreach ($this->data as $id=> &$node){
      if (!$node['parent_id']){
      //родительская категория
        $tree[$id] = &$node;
    }  else{
      //БЕРЕМ дочернию категорию и по её $node['parent_id'](например 12) и ПОМЕЩАЕМ в элемент массива категорий([id] => 12) как узел-массив с ключом равном значению айдишника [$node['id']] категории (например если у дочерней категории [id] => 14 то ключ узла соответственно [14] => Array)  в  созданное сейчас поле children в  массивe родительской категории(соответственно с [id] => 12) , то есть  ЗНАЧЕНИЕ узла &$node ([id] => 14) СТАНОВИТСЯ вложенным элементом  массива([14] => Array) поля children (категории с [id] => 12):
//        [12] => Array
//        (
//          [id] => 12
//            [parent_id] => 0
//            [title] => Frozen Foods
//            [children] => Array
//                (
//                  [13] => Array
//                  (
//                      [id] => 13
//                      [parent_id] => 12
//                      [title] => Frozen Snacks
//                                    )//
//                 [14] => Array
//                  (
//                      [id] => 14                                                               [parent_id] => 12
//                      [title] => Frozen Nonveg
//                                        )//
//                              )//
//          )
      $this->data[$node['parent_id']]['children'][$node['id']] = &$node;
    }
  }
    //возвращаем иерархический массив со вложенными массивами дочерних категорий в родительские
    return $tree;
  }
//метод проходит по всему дереву $tree брать каждую конкретно категорию (внутри цикла метод getMenuHtml вызывается рекурсивно из шаблона DIR__ . '/menu_tpl/' . $this->tpl и передавать ему эту категорию если есть потомки и соответственно необходимый узел а не дерево целиком, поэтому в параметре метода передаем свойство $tree) и вызывать метод catToTemplate и передавать эту категорию в шаблон , она будет добавлятся в шаблон через буфер и складываться в переменную $str. возвращает строку HTML
  protected function getMenuHtml($tree ,  $tab=''){
    // $tab это отступ  вначале строки ,применяется в шаблоне select в названиях категорий, у ктегорий верхнего  уровня он нулевой, а для вложенных категорий будет передан в параметре
    $str = '';
    foreach ($tree as $category) {
      $str .= $this->catToTemplate($category,$tab);
    }
    return $str;
  }


//получаетт категорию $category и отступ $tab из getMenuHtml загоняет её в буфер и подключает шаблон,полученный из свойства
// tpl, в
// шаблоне
// будет прописана верстка для каждой категории
  protected function catToTemplate($category, $tab){
    ob_start();
    include __DIR__ . '/menu_tpl/' . $this->tpl;
    return ob_get_clean();
  }
}